<?php require_once('PelEntryUndefined.php'); require_once('PelEntryRational.php'); require_once('PelDataWindow.php'); require_once('PelEntryAscii.php'); require_once('PelEntryShort.php'); require_once('PelEntryByte.php'); require_once('PelEntryLong.php'); require_once('PelException.php'); require_once('PelFormat.php'); require_once('PelEntry.php'); require_once('PelTag.php'); require_once('Pel.php'); class PelIfdException extends PelException {} class PelIfd implements IteratorAggregate, ArrayAccess { const IFD0 = 0; const IFD1 = 1; const EXIF = 2; const GPS = 3; const INTEROPERABILITY = 4; private $entries = array(); private $type; private $next = null; private $sub = array(); private $thumb_data = null; function __construct($type) { if ($type != PelIfd::IFD0 && $type != PelIfd::IFD1 && $type != PelIfd::EXIF && $type != PelIfd::GPS && $type != PelIfd::INTEROPERABILITY) throw new PelIfdException('Unknown IFD type: %d', $type); $this->type = $type; } function load(PelDataWindow $d, $offset) { $thumb_offset = 0; $thumb_length = 0; Pel::debug('Constructing IFD at offset %d from %d bytes...', $offset, $d->getSize()); $n = $d->getShort($offset); Pel::debug('Loading %d entries...', $n); $offset += 2; if ($offset + 12 * $n > $d->getSize()) { $n = floor(($offset - $d->getSize()) / 12); Pel::maybeThrow(new PelIfdException('Adjusted to: %d.', $n)); } for ($i = 0; $i < $n; $i++) { $tag = $d->getShort($offset + 12 * $i); Pel::debug('Loading entry with tag 0x%04X: %s (%d of %d)...', $tag, PelTag::getName($this->type, $tag), $i + 1, $n); switch ($tag) { case PelTag::EXIF_IFD_POINTER: case PelTag::GPS_INFO_IFD_POINTER: case PelTag::INTEROPERABILITY_IFD_POINTER: $o = $d->getLong($offset + 12 * $i + 8); Pel::debug('Found sub IFD at offset %d', $o); if ($tag == PelTag::EXIF_IFD_POINTER) $type = PelIfd::EXIF; elseif ($tag == PelTag::GPS_INFO_IFD_POINTER) $type = PelIfd::GPS; elseif ($tag == PelTag::INTEROPERABILITY_IFD_POINTER) $type = PelIfd::INTEROPERABILITY; $this->sub[$type] = new PelIfd($type); $this->sub[$type]->load($d, $o); break; case PelTag::JPEG_INTERCHANGE_FORMAT: $thumb_offset = $d->getLong($offset + 12 * $i + 8); $this->safeSetThumbnail($d, $thumb_offset, $thumb_length); break; case PelTag::JPEG_INTERCHANGE_FORMAT_LENGTH: $thumb_length = $d->getLong($offset + 12 * $i + 8); $this->safeSetThumbnail($d, $thumb_offset, $thumb_length); break; default: $format = $d->getShort($offset + 12 * $i + 2); $components = $d->getLong($offset + 12 * $i + 4); $s = PelFormat::getSize($format) * $components; if ($s > 0) { $doff = $offset + 12 * $i + 8; if ($s > 4) $doff = $d->getLong($doff); $data = $d->getClone($doff, $s); } else { $data = new PelDataWindow(); } try { $entry = $this->newEntryFromData($tag, $format, $components, $data); if ($this->isValidTag($tag)) { $entry->setIfdType($this->type); $this->entries[$tag] = $entry; } else { Pel::maybeThrow(new PelInvalidDataException("IFD %s cannot hold\n%s", $this->getName(), $entry->__toString())); } } catch (PelException $e) { Pel::maybeThrow($e); } break; } } $o = $d->getLong($offset + 12 * $n); Pel::debug('Current offset is %d, link at %d points to %d.', $offset, $offset + 12 * $n, $o); if ($o > 0) { if ($o > $d->getSize() - 6) { Pel::maybeThrow(new PelIfdException('Bogus offset to next IFD: ' . '%d > %d!', $o, $d->getSize() - 6)); } else { if ($this->type == PelIfd::IFD1) Pel::maybeThrow(new PelIfdException('IFD1 links to another IFD!')); $this->next = new PelIfd(PelIfd::IFD1); $this->next->load($d, $o); } } else { Pel::debug('Last IFD.'); } } function newEntryFromData($tag, $format, $components, PelDataWindow $data) { switch ($this->type) { case self::IFD0: case self::IFD1: case self::EXIF: case self::INTEROPERABILITY: switch ($tag) { case PelTag::DATE_TIME: case PelTag::DATE_TIME_ORIGINAL: case PelTag::DATE_TIME_DIGITIZED: if ($format != PelFormat::ASCII) throw new PelUnexpectedFormatException($this->type, $tag, $format, PelFormat::ASCII); if ($components != 20) throw new PelWrongComponentCountException($this->type, $tag, $components, 20); return new PelEntryTime($tag, $data->getBytes(0, -1), PelEntryTime::EXIF_STRING); case PelTag::COPYRIGHT: if ($format != PelFormat::ASCII) throw new PelUnexpectedFormatException($this->type, $tag, $format, PelFormat::ASCII); $v = explode("\0", trim($data->getBytes(), ' ')); return new PelEntryCopyright($v[0], $v[1]); case PelTag::EXIF_VERSION: case PelTag::FLASH_PIX_VERSION: case PelTag::INTEROPERABILITY_VERSION: if ($format != PelFormat::UNDEFINED) throw new PelUnexpectedFormatException($this->type, $tag, $format, PelFormat::UNDEFINED); return new PelEntryVersion($tag, $data->getBytes() / 100); case PelTag::USER_COMMENT: if ($format != PelFormat::UNDEFINED) throw new PelUnexpectedFormatException($this->type, $tag, $format, PelFormat::UNDEFINED); if ($data->getSize() < 8) { return new PelEntryUserComment(); } else { return new PelEntryUserComment($data->getBytes(8), rtrim($data->getBytes(0, 8))); } case PelTag::XP_TITLE: case PelTag::XP_COMMENT: case PelTag::XP_AUTHOR: case PelTag::XP_KEYWORDS: case PelTag::XP_SUBJECT: if ($format != PelFormat::BYTE) throw new PelUnexpectedFormatException($this->type, $tag, $format, PelFormat::BYTE); $v = ''; for ($i = 0; $i < $components; $i++) { $b = $data->getByte($i); if ($b != 0) $v .= chr($b); } return new PelEntryWindowsString($tag, $v); } case self::GPS: default: switch ($format) { case PelFormat::BYTE: $v = new PelEntryByte($tag); for ($i = 0; $i < $components; $i++) $v->addNumber($data->getByte($i)); return $v; case PelFormat::SBYTE: $v = new PelEntrySByte($tag); for ($i = 0; $i < $components; $i++) $v->addNumber($data->getSByte($i)); return $v; case PelFormat::ASCII: return new PelEntryAscii($tag, $data->getBytes(0, -1)); case PelFormat::SHORT: $v = new PelEntryShort($tag); for ($i = 0; $i < $components; $i++) $v->addNumber($data->getShort($i*2)); return $v; case PelFormat::SSHORT: $v = new PelEntrySShort($tag); for ($i = 0; $i < $components; $i++) $v->addNumber($data->getSShort($i*2)); return $v; case PelFormat::LONG: $v = new PelEntryLong($tag); for ($i = 0; $i < $components; $i++) $v->addNumber($data->getLong($i*4)); return $v; case PelFormat::SLONG: $v = new PelEntrySLong($tag); for ($i = 0; $i < $components; $i++) $v->addNumber($data->getSLong($i*4)); return $v; case PelFormat::RATIONAL: $v = new PelEntryRational($tag); for ($i = 0; $i < $components; $i++) $v->addNumber($data->getRational($i*8)); return $v; case PelFormat::SRATIONAL: $v = new PelEntrySRational($tag); for ($i = 0; $i < $components; $i++) $v->addNumber($data->getSRational($i*8)); return $v; case PelFormat::UNDEFINED: return new PelEntryUndefined($tag, $data->getBytes()); default: throw new PelException('Unsupported format: %s', PelFormat::getName($format)); } } } private function safeSetThumbnail(PelDataWindow $d, $offset, $length) { if ($offset > 0 && $length > 0) { if ($offset + $length > $d->getSize()) { Pel::maybeThrow(new PelIfdException('Thumbnail length %d bytes ' . 'adjusted to %d bytes.', $length, $d->getSize() - $offset)); $length = $d->getSize() - $offset; } $this->setThumbnail($d->getClone($offset, $length)); } } function setThumbnail(PelDataWindow $d) { $size = $d->getSize(); while ($d->getByte($size - 2) != 0xFF || $d->getByte($size - 1) != PelJpegMarker::EOI) { $size--; } if ($size != $d->getSize()) Pel::maybeThrow(new PelIfdException('Decrementing thumbnail size ' . 'to %d bytes', $size)); $this->thumb_data = $d->getClone(0, $size); } function getType() { return $this->type; } function isValidTag($tag) { return $tag > 0xF000 || in_array($tag, $this->getValidTags()); } function getValidTags() { switch ($this->type) { case PelIfd::IFD0: case PelIfd::IFD1: return array(PelTag::IMAGE_WIDTH, PelTag::IMAGE_LENGTH, PelTag::BITS_PER_SAMPLE, PelTag::COMPRESSION, PelTag::PHOTOMETRIC_INTERPRETATION, PelTag::IMAGE_DESCRIPTION, PelTag::MAKE, PelTag::MODEL, PelTag::STRIP_OFFSETS, PelTag::ORIENTATION, PelTag::SAMPLES_PER_PIXEL, PelTag::ROWS_PER_STRIP, PelTag::STRIP_BYTE_COUNTS, PelTag::X_RESOLUTION, PelTag::Y_RESOLUTION, PelTag::PLANAR_CONFIGURATION, PelTag::RESOLUTION_UNIT, PelTag::TRANSFER_FUNCTION, PelTag::SOFTWARE, PelTag::DATE_TIME, PelTag::ARTIST, PelTag::WHITE_POINT, PelTag::PRIMARY_CHROMATICITIES, PelTag::JPEG_INTERCHANGE_FORMAT, PelTag::JPEG_INTERCHANGE_FORMAT_LENGTH, PelTag::YCBCR_COEFFICIENTS, PelTag::YCBCR_SUB_SAMPLING, PelTag::YCBCR_POSITIONING, PelTag::REFERENCE_BLACK_WHITE, PelTag::COPYRIGHT, PelTag::EXIF_IFD_POINTER, PelTag::GPS_INFO_IFD_POINTER, PelTag::PRINT_IM); case PelIfd::EXIF: return array(PelTag::EXPOSURE_TIME, PelTag::FNUMBER, PelTag::EXPOSURE_PROGRAM, PelTag::SPECTRAL_SENSITIVITY, PelTag::ISO_SPEED_RATINGS, PelTag::OECF, PelTag::EXIF_VERSION, PelTag::DATE_TIME_ORIGINAL, PelTag::DATE_TIME_DIGITIZED, PelTag::COMPONENTS_CONFIGURATION, PelTag::COMPRESSED_BITS_PER_PIXEL, PelTag::SHUTTER_SPEED_VALUE, PelTag::APERTURE_VALUE, PelTag::BRIGHTNESS_VALUE, PelTag::EXPOSURE_BIAS_VALUE, PelTag::MAX_APERTURE_VALUE, PelTag::SUBJECT_DISTANCE, PelTag::METERING_MODE, PelTag::LIGHT_SOURCE, PelTag::FLASH, PelTag::FOCAL_LENGTH, PelTag::MAKER_NOTE, PelTag::USER_COMMENT, PelTag::SUB_SEC_TIME, PelTag::SUB_SEC_TIME_ORIGINAL, PelTag::SUB_SEC_TIME_DIGITIZED, PelTag::XP_TITLE, PelTag::XP_COMMENT, PelTag::XP_AUTHOR, PelTag::XP_KEYWORDS, PelTag::XP_SUBJECT, PelTag::FLASH_PIX_VERSION, PelTag::COLOR_SPACE, PelTag::PIXEL_X_DIMENSION, PelTag::PIXEL_Y_DIMENSION, PelTag::RELATED_SOUND_FILE, PelTag::FLASH_ENERGY, PelTag::SPATIAL_FREQUENCY_RESPONSE, PelTag::FOCAL_PLANE_X_RESOLUTION, PelTag::FOCAL_PLANE_Y_RESOLUTION, PelTag::FOCAL_PLANE_RESOLUTION_UNIT, PelTag::SUBJECT_LOCATION, PelTag::EXPOSURE_INDEX, PelTag::SENSING_METHOD, PelTag::FILE_SOURCE, PelTag::SCENE_TYPE, PelTag::CFA_PATTERN, PelTag::CUSTOM_RENDERED, PelTag::EXPOSURE_MODE, PelTag::WHITE_BALANCE, PelTag::DIGITAL_ZOOM_RATIO, PelTag::FOCAL_LENGTH_IN_35MM_FILM, PelTag::SCENE_CAPTURE_TYPE, PelTag::GAIN_CONTROL, PelTag::CONTRAST, PelTag::SATURATION, PelTag::SHARPNESS, PelTag::DEVICE_SETTING_DESCRIPTION, PelTag::SUBJECT_DISTANCE_RANGE, PelTag::IMAGE_UNIQUE_ID, PelTag::INTEROPERABILITY_IFD_POINTER, PelTag::GAMMA); case PelIfd::GPS: return array(PelTag::GPS_VERSION_ID, PelTag::GPS_LATITUDE_REF, PelTag::GPS_LATITUDE, PelTag::GPS_LONGITUDE_REF, PelTag::GPS_LONGITUDE, PelTag::GPS_ALTITUDE_REF, PelTag::GPS_ALTITUDE, PelTag::GPS_TIME_STAMP, PelTag::GPS_SATELLITES, PelTag::GPS_STATUS, PelTag::GPS_MEASURE_MODE, PelTag::GPS_DOP, PelTag::GPS_SPEED_REF, PelTag::GPS_SPEED, PelTag::GPS_TRACK_REF, PelTag::GPS_TRACK, PelTag::GPS_IMG_DIRECTION_REF, PelTag::GPS_IMG_DIRECTION, PelTag::GPS_MAP_DATUM, PelTag::GPS_DEST_LATITUDE_REF, PelTag::GPS_DEST_LATITUDE, PelTag::GPS_DEST_LONGITUDE_REF, PelTag::GPS_DEST_LONGITUDE, PelTag::GPS_DEST_BEARING_REF, PelTag::GPS_DEST_BEARING, PelTag::GPS_DEST_DISTANCE_REF, PelTag::GPS_DEST_DISTANCE, PelTag::GPS_PROCESSING_METHOD, PelTag::GPS_AREA_INFORMATION, PelTag::GPS_DATE_STAMP, PelTag::GPS_DIFFERENTIAL); case PelIfd::INTEROPERABILITY: return array(PelTag::INTEROPERABILITY_INDEX, PelTag::INTEROPERABILITY_VERSION, PelTag::RELATED_IMAGE_FILE_FORMAT, PelTag::RELATED_IMAGE_WIDTH, PelTag::RELATED_IMAGE_LENGTH); } } static function getTypeName($type) { switch ($type) { case self::IFD0: return '0'; case self::IFD1: return '1'; case self::EXIF: return 'Exif'; case self::GPS: return 'GPS'; case self::INTEROPERABILITY: return 'Interoperability'; default: throw new PelIfdException('Unknown IFD type: %d', $type); } } function getName() { return $this->getTypeName($this->type); } function addEntry(PelEntry $e) { $this->entries[$e->getTag()] = $e; } function offsetExists($tag) { return isset($this->entries[$tag]); } function offsetGet($tag) { return $this->entries[$tag]; } function offsetSet($tag, $e) { if ($e instanceof PelEntry) { $tag = $e->getTag(); $this->entries[$tag] = $e; } else { throw new PelInvalidArgumentException('Argument "%s" must be a PelEntry.', $e); } } function offsetUnset($tag) { unset($this->entries[$tag]); } function getEntry($tag) { if (isset($this->entries[$tag])) return $this->entries[$tag]; else return null; } function getEntries() { return $this->entries; } function getIterator() { return new ArrayIterator($this->entries); } function getThumbnailData() { if ($this->thumb_data != null) return $this->thumb_data->getBytes(); else return ''; } function setNextIfd(PelIfd $i) { $this->next = $i; } function getNextIfd() { return $this->next; } function isLastIfd() { return $this->next == null; } function addSubIfd(PelIfd $sub) { $this->sub[$sub->type] = $sub; } function getSubIfd($type) { if (isset($this->sub[$type])) return $this->sub[$type]; else return null; } function getSubIfds() { return $this->sub; } function getBytes($offset, $order) { $bytes = ''; $extra_bytes = ''; Pel::debug('Bytes from IDF will start at offset %d within Exif data', $offset); $n = count($this->entries) + count($this->sub); if ($this->thumb_data != null) { $n += 2; } $bytes .= PelConvert::shortToBytes($n, $order); $end = $offset + 2 + 12 * $n + 4; foreach ($this->entries as $tag => $entry) { $bytes .= PelConvert::shortToBytes($entry->getTag(), $order); $bytes .= PelConvert::shortToBytes($entry->getFormat(), $order); $bytes .= PelConvert::longToBytes($entry->getComponents(), $order); $data = $entry->getBytes($order); $s = strlen($data); if ($s > 4) { Pel::debug('Data size %d too big, storing at offset %d instead.', $s, $end); $bytes .= PelConvert::longToBytes($end, $order); $extra_bytes .= $data; $end += $s; } else { Pel::debug('Data size %d fits.', $s); $bytes .= $data . str_repeat(chr(0), 4 - $s); } } if ($this->thumb_data != null) { Pel::debug('Appending %d bytes of thumbnail data at %d', $this->thumb_data->getSize(), $end); $bytes .= PelConvert::shortToBytes(PelTag::JPEG_INTERCHANGE_FORMAT_LENGTH, $order); $bytes .= PelConvert::shortToBytes(PelFormat::LONG, $order); $bytes .= PelConvert::longToBytes(1, $order); $bytes .= PelConvert::longToBytes($this->thumb_data->getSize(), $order); $bytes .= PelConvert::shortToBytes(PelTag::JPEG_INTERCHANGE_FORMAT, $order); $bytes .= PelConvert::shortToBytes(PelFormat::LONG, $order); $bytes .= PelConvert::longToBytes(1, $order); $bytes .= PelConvert::longToBytes($end, $order); $extra_bytes .= $this->thumb_data->getBytes(); $end += $this->thumb_data->getSize(); } $sub_bytes = ''; foreach ($this->sub as $type => $sub) { if ($type == PelIfd::EXIF) $tag = PelTag::EXIF_IFD_POINTER; elseif ($type == PelIfd::GPS) $tag = PelTag::GPS_INFO_IFD_POINTER; elseif ($type == PelIfd::INTEROPERABILITY) $tag = PelTag::INTEROPERABILITY_IFD_POINTER; $bytes .= PelConvert::shortToBytes($tag, $order); $bytes .= PelConvert::shortToBytes(PelFormat::LONG, $order); $bytes .= PelConvert::longToBytes(1, $order); $data = $sub->getBytes($end, $order); $s = strlen($data); $sub_bytes .= $data; $bytes .= PelConvert::longToBytes($end, $order); $end += $s; } if ($this->isLastIFD()) { $link = 0; } else { $link = $end; } Pel::debug('Link to next IFD: %d', $link); $bytes .= PelConvert::longtoBytes($link, $order); $bytes .= $extra_bytes . $sub_bytes; if (!$this->isLastIfd()) $bytes .= $this->next->getBytes($end, $order); return $bytes; } function __toString() { $str = Pel::fmt("Dumping IFD %s with %d entries...\n", $this->getName(), count($this->entries)); foreach ($this->entries as $entry) $str .= $entry->__toString(); $str .= Pel::fmt("Dumping %d sub IFDs...\n", count($this->sub)); foreach ($this->sub as $type => $ifd) $str .= $ifd->__toString(); if ($this->next != null) $str .= $this->next->__toString(); return $str; } } ?>