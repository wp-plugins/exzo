<?php require_once('PelJpegComment.php'); require_once('PelJpegContent.php'); require_once('PelDataWindow.php'); require_once('PelJpegMarker.php'); require_once('PelException.php'); require_once('PelExif.php'); require_once('Pel.php'); class PelJpegInvalidMarkerException extends PelException { function __construct($marker, $offset) { parent::__construct('Invalid marker found at offset %d: 0x%2X', $offset, $marker); } } class PelJpeg { private $sections = array(); private $jpeg_data = null; function __construct($data = false) { if ($data === false) return; if (is_string($data)) { Pel::debug('Initializing PelJpeg object from %s', $data); $this->loadFile($data); } elseif ($data instanceof PelDataWindow) { Pel::debug('Initializing PelJpeg object from PelDataWindow.'); $this->load($data); } elseif (is_resource($data) && get_resource_type($data) == 'gd') { Pel::debug('Initializing PelJpeg object from image resource.'); ob_start(); ImageJpeg($data); $bytes = ob_get_clean(); $this->load(new PelDataWindow($bytes)); } else { throw new PelInvalidArgumentException('Bad type for $data: %s', gettype($data)); } } function load(PelDataWindow $d) { Pel::debug('Parsing %d bytes...', $d->getSize()); $d->setByteOrder(PelConvert::BIG_ENDIAN); while ($d->getSize() > 0) { for ($i = 0; $i < 7; $i++) if ($d->getByte($i) != 0xFF) break; $marker = $d->getByte($i); if (!PelJpegMarker::isValid($marker)) throw new PelJpegInvalidMarkerException($marker, $i); $d->setWindowStart($i+1); if ($marker == PelJpegMarker::SOI || $marker == PelJpegMarker::EOI) { $content = new PelJpegContent(new PelDataWindow()); $this->appendSection($marker, $content); } else { $len = $d->getShort(0) - 2; Pel::debug('Found %s section of length %d', PelJpegMarker::getName($marker), $len); $d->setWindowStart(2); if ($marker == PelJpegMarker::APP1) { try { $content = new PelExif(); $content->load($d->getClone(0, $len)); } catch (PelInvalidDataException $e) { $content = new PelJpegContent($d->getClone(0, $len)); } $this->appendSection($marker, $content); $d->setWindowStart($len); } elseif ($marker == PelJpegMarker::COM) { $content = new PelJpegComment(); $content->load($d->getClone(0, $len)); $this->appendSection($marker, $content); $d->setWindowStart($len); } else { $content = new PelJpegContent($d->getClone(0, $len)); $this->appendSection($marker, $content); $d->setWindowStart($len); if ($marker == PelJpegMarker::SOS) { $length = $d->getSize(); while ($d->getByte($length-2) != 0xFF || $d->getByte($length-1) != PelJpegMarker::EOI) { $length--; } $this->jpeg_data = $d->getClone(0, $length-2); Pel::debug('JPEG data: ' . $this->jpeg_data->__toString()); $this->appendSection(PelJpegMarker::EOI, new PelJpegContent(new PelDataWindow())); if ($length != $d->getSize()) { Pel::maybeThrow(new PelException('Found trailing content ' . 'after EOI: %d bytes', $d->getSize() - $length)); $content = new PelJpegContent($d->getClone($length)); $this->appendSection(0x00, $content); } break; } } } } } function loadFile($filename) { $this->load(new PelDataWindow(file_get_contents($filename))); } function setExif(PelExif $exif) { $app0_offset = 1; $app1_offset = -1; for ($i = 0; $i < count($this->sections); $i++) { if ($this->sections[$i][0] == PelJpegMarker::APP0) { $app0_offset = $i; } elseif ($this->sections[$i][0] == PelJpegMarker::APP1) { $app1_offset = $i; break; } } if ($app1_offset > 0) $this->sections[$app1_offset][1] = $exif; else $this->insertSection(PelJpegMarker::APP1, $exif, $app0_offset+1); } function getExif() { $exif = $this->getSection(PelJpegMarker::APP1); if ($exif instanceof PelExif) return $exif; else return null; } function clearExif() { for ($i = 0; $i < count($this->sections); $i++) { if ($this->sections[$i][0] == PelJpegMarker::APP1) { unset($this->sections[$i]); return; } } } function appendSection($marker, PelJpegContent $content) { $this->sections[] = array($marker, $content); } function insertSection($marker, PelJpegContent $content, $offset) { array_splice($this->sections, $offset, 0, array(array($marker, $content))); } function getSection($marker, $skip = 0) { foreach ($this->sections as $s) { if ($s[0] == $marker) if ($skip > 0) $skip--; else return $s[1]; } return null; } function getSections() { return $this->sections; } function getBytes() { $bytes = ''; foreach ($this->sections as $section) { $m = $section[0]; $c = $section[1]; $bytes .= "\xFF" . PelJpegMarker::getBytes($m); if ($m == PelJpegMarker::SOI || $m == PelJpegMarker::EOI) continue; $data = $c->getBytes(); $size = strlen($data) + 2; $bytes .= PelConvert::shortToBytes($size, PelConvert::BIG_ENDIAN); $bytes .= $data; if ($m == PelJpegMarker::SOS) $bytes .= $this->jpeg_data->getBytes(); } return $bytes; } function __toString() { $str = Pel::tra("Dumping JPEG data...\n"); for ($i = 0; $i < count($this->sections); $i++) { $m = $this->sections[$i][0]; $c = $this->sections[$i][1]; $str .= Pel::fmt("Section %d (marker 0x%02X - %s):\n", $i, $m, PelJpegMarker::getName($m)); $str .= Pel::fmt("  Description: %s\n", PelJpegMarker::getDescription($m)); if ($m == PelJpegMarker::SOI || $m == PelJpegMarker::EOI) continue; if ($c instanceof PelExif) { $str .= Pel::tra("  Content    : Exif data\n"); $str .= $c->__toString() . "\n"; } elseif ($c instanceof PelJpegComment) { $str .= Pel::fmt("  Content    : %s\n", $c->getValue()); } else { $str .= Pel::tra("  Content    : Unknown\n"); } } return $str; } static function isValid(PelDataWindow $d) { $d->setByteOrder(PelConvert::BIG_ENDIAN); for ($i = 0; $i < 7; $i++) if ($d->getByte($i) != 0xFF) break; return $d->getByte($i) == PelJpegMarker::SOI; } } ?>