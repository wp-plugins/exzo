<?php require_once('PelException.php'); require_once('PelConvert.php'); class PelDataWindowOffsetException extends PelException {} class PelDataWindowWindowException extends PelException {} class PelDataWindow { private $data = ''; private $order; private $start = 0; private $size = 0; function __construct($d = '', $e = PelConvert::LITTLE_ENDIAN) { $this->data = $d; $this->order = $e; $this->size = strlen($d); } function getSize() { return $this->size; } function setByteOrder($o) { $this->order = $o; } function getByteOrder() { return $this->order; } function setWindowStart($start) { if ($start < 0 || $start > $this->size) throw new PelDataWindowWindowException('Window [%d, %d] does ' . 'not fit in window [0, %d]', $start, $this->size, $this->size); $this->start += $start; $this->size -= $start; } function setWindowSize($size) { if ($size < 0) $size += $this->size; if ($size < 0 || $size > $this->size) throw new PelDataWindowWindowException('Window [0, %d] ' . 'does not fit in window [0, %d]', $size, $this->size); $this->size = $size; } function getClone($start = false, $size = false) { $c = clone $this; if (is_int($start)) $c->setWindowStart($start); if (is_int($size)) $c->setWindowSize($size); return $c; } private function validateOffset($o) { if ($o < 0 || $o >= $this->size) throw new PelDataWindowOffsetException('Offset %d not within [%d, %d]', $o, 0, $this->size-1); } function getBytes($start = false, $size = false) { if (is_int($start)) { if ($start < 0) $start += $this->size; $this->validateOffset($start); } else { $start = 0; } if (is_int($size)) { if ($size <= 0) $size += $this->size - $start; $this->validateOffset($start+$size); } else { $size = $this->size - $start; } return substr($this->data, $this->start + $start, $size); } function getByte($o = 0) { $this->validateOffset($o); $o += $this->start; return PelConvert::bytesToByte($this->data, $o); } function getSByte($o = 0) { $this->validateOffset($o); $o += $this->start; return PelConvert::bytesToSByte($this->data, $o); } function getShort($o = 0) { $this->validateOffset($o); $this->validateOffset($o+1); $o += $this->start; return PelConvert::bytesToShort($this->data, $o, $this->order); } function getSShort($o = 0) { $this->validateOffset($o); $this->validateOffset($o+1); $o += $this->start; return PelConvert::bytesToSShort($this->data, $o, $this->order); } function getLong($o = 0) { $this->validateOffset($o); $this->validateOffset($o+3); $o += $this->start; return PelConvert::bytesToLong($this->data, $o, $this->order); } function getSLong($o = 0) { $this->validateOffset($o); $this->validateOffset($o+3); $o += $this->start; return PelConvert::bytesToSLong($this->data, $o, $this->order); } function getRational($o = 0) { return array($this->getLong($o), $this->getLong($o+4)); } function getSRational($o = 0) { return array($this->getSLong($o), $this->getSLong($o+4)); } function strcmp($o, $str) { $s = strlen($str); $this->validateOffset($o); $this->validateOffset($o + $s - 1); $o += $this->start; for ($i = 0; $i < $s; $i++) { if ($this->data{$o + $i} != $str{$i}) return false; } return true; } function __toString() { return Pel::fmt('DataWindow: %d bytes in [%d, %d] of %d bytes', $this->size, $this->start, $this->start + $this->size, strlen($this->data)); } } ?>