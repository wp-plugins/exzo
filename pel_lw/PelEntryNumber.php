<?php require_once('PelException.php'); require_once('PelEntry.php'); class PelOverflowException extends PelException { function __construct($v, $min, $max) { parent::__construct('Value %.0f out of range [%.0f, %.0f]', $v, $min, $max); } } abstract class PelEntryNumber extends PelEntry { protected $value = array(); protected $min; protected $max; protected $dimension = 1; function setValue() { $value = func_get_args(); $this->setValueArray($value); } function setValueArray($value) { foreach ($value as $v) $this->validateNumber($v); $this->components = count($value); $this->value = $value; } function getValue() { if ($this->components == 1) return $this->value[0]; else return $this->value; } function validateNumber($n) { if ($this->dimension == 1) { if ($n < $this->min || $n > $this->max) Pel::maybeThrow(new PelOverflowException($n, $this->min, $this->max)); } else { for ($i = 0; $i < $this->dimension; $i++) if ($n[$i] < $this->min || $n[$i] > $this->max) Pel::maybeThrow(new PelOverflowException($n[$i], $this->min, $this->max)); } } function addNumber($n) { $this->validateNumber($n); $this->value[] = $n; $this->components++; } abstract function numberToBytes($number, $order); function getBytes($o) { $bytes = ''; for ($i = 0; $i < $this->components; $i++) { if ($this->dimension == 1) { $bytes .= $this->numberToBytes($this->value[$i], $o); } else { for ($j = 0; $j < $this->dimension; $j++) { $bytes .= $this->numberToBytes($this->value[$i][$j], $o); } } } return $bytes; } function formatNumber($number, $brief = false) { return $number; } function getText($brief = false) { if ($this->components == 0) return ''; $str = $this->formatNumber($this->value[0]); for ($i = 1; $i < $this->components; $i++) { $str .= ($brief ? ' ' : ', '); $str .= $this->formatNumber($this->value[$i]); } return $str; } } ?>